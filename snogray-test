#!/bin/sh
#
# Test script for snogray.
#
# Usage: snogray-test [OPTION...] SNOGRAY_EXECUTABLE TEST...
#
# Where TEST is either a scene file or a directory containing scene
# files.  If it is a directory, snogray-test will process all tests in
# that directory.  The directory containing a test file is known as
# the "test directory," and other files will be located there.
#
# Only scene files with the following extensions are processed:
#
#   .pbrt    PBRT format scenes  
#   .lua     Native snogray scenes written using Lua
#
# In addition to scene-files, the test directory can contain special
# files with the following names:
#
#   ref/     A directory containing reference images for each test,
#            which are compared with the output of the test scene files.
#
#   SUBDIRS  A list of subdirectories, also holding tests
#

SNOGRAY=${SNOGRAY:-snogray}
SNOGDIFF=${SNOGDIFF:-snogdiff}
SNOGCVT=${SNOGCVT:-snogcvt}
PBRT=${PBRT:-pbrt}
PBRT_OPTIONS=${PBRT_OPTIONS:-}

quiet=no
update_ref_images=no
log_dir=''

out_ext=exr
reference_ext=exr

me=$(basename $0)

AWK=/usr/bin/nawk

optarg () {
  opt=$1
}

read_params_file () {
  params_file=$1
  if test x"$params_file" != x; then
    if test -r "$params_file"; then
      . "$params_file" || exit 3
    else
      echo 1>&2 "$me: $params_file: Parameter file not found"
      exit 2
    fi
  fi
}

while :; do
  case "$1" in
    -q|--quiet)
      quiet=yes; shift;;
    -p|--params|--params-file)
      read_params_file "$2"; shift 2;;
    -p*)
      read_params_file "$(echo "$1" | sed 's@^..@@')"; shift;;
    --params=*|--params-file=*)
      read_params_file "$(echo "$1" | sed 's@^.*=@@')"; shift;;
    -l|--log-dir)
      log_dir=$2; shift 2;;
    -l*)
      log_dir=$(echo "$1" | sed 's@^..@@'); shift;;
    --log-dir=*)
      log_dir=$(echo "$1" | sed 's@^.*=@@'); shift;;
    -*)
      echo 1>&2 "$me: Unknown option '$1'"; exit 1;;
    *=*)
      eval "$1"; shift;;
    *)
      break;;
  esac      
done

abs_filename () {
  case "$1" in
    /*)  echo "$1" ;;
    */*) ( cd "$(dirname "$1")"; echo "$(pwd)/$(basename "$1")"; ) ;;
    *)   echo "$(pwd)/$(basename "$1")" ;;
  esac
}

no_trailing_slash () {
  echo "$1" | sed 's@\([^/]\)/*$@\1@'
}


# Find an executable called "$1", first searching directory "$2" if it
# is non-empty, and then searching $PATH when appropriate (following the
# same rules as the shell), print its absolute path on stdout, and
# return success.  If no executable is found, return failure.
#
find_exec () {
  prog=$1
  case "$prog" in
    */*)
      prog=$(abs_filename "$prog")
      if test -x "$prog"; then
	echo "$prog"
	return 0
      fi
      ;;
    *)
      path=$PATH
      test x"$2" = x || path="$2:$path"
      IFS=":"
      for dir in $path; do
	file="$dir/$prog"
	if test -x "$file"; then
	  echo "$file"
	  return 0
	fi
      done
      ;;
  esac
  return 1
}

locate_prog () {
  varname=$1
  extra_search_dir=$2
  eval val='$'"$varname"
  new_val=$(find_exec "$val" "$extra_search_dir") || {
    echo 1>&2 "$me: Program '$val' not found"
    echo 1>&2 "$me: Use the variable $varname to specify an explicit name"
    exit 6
  }
  eval "$varname='$new_val'"
}

locate_prog SNOGRAY
snogray_dir=$(dirname "$SNOGRAY")

locate_prog SNOGDIFF "$snogray_dir"
locate_prog SNOGCVT "$snogray_dir"
locate_prog PBRT

tmpdir="/tmp/,$me-$$"
cleanup_cmd="rm -rf '$tmpdir'"
for sig in 1 2 3 13 15; do
  trap "$cleanup_cmd; trap $sig; kill -$sig \$\$" $sig;
done
trap "$cleanup_cmd" 0
mkdir "$tmpdir" || exit 4

rundir="$tmpdir/run"
mkdir "$rundir" || exit 5

outdir="$tmpdir/out"
mkdir "$outdir" || exit 6

if test x"$log_dir" != x; then
  if test -d "$log_dir"; then
    rm -f "$log_dir"/*
  else
    mkdir "$log_dir" || exit 8
  fi
fi


# Run snogray on the test scene file $1, placing the output into $2.
# Remaining arguments are passed to snogray.  Return status is 0 for a
# successful run, and non-zero if snogray failed.
#
run_snogray ()
{
  scene="$1"; shift
  output="$1"; shift

  (
    # Snogray prefers to run in the build directory when not
    # installed, and it's harmless to run in the binary directory
    # otherwise, so just chdir there.
    #
    cd "$snogray_dir"

    "$SNOGRAY" 2>&1 "$@" "$scene" "$output"
  )
}

# Run pbrt on the test scene file $1, placing the output into $2.
# Remaining arguments are passed to pbrt.  Return status is 0 for a
# successful run, and non-zero if pbrt failed.
#
run_pbrt ()
{
  scene="$1"; shift
  output="$1"; shift

  rm -f "$rundir"/*

  (
    cd "$rundir"
    "$PBRT" 2>&1 $PBRT_OPTIONS "$@" "$scene"
    pbrt_output_file="$(ls *.exr | head -n1)"
    if test -r "$pbrt_output_file"; then
      cp 2>&1 "$pbrt_output_file" "$output"
    else
      echo "No PBRT output file found!"
      return 1
    fi
  )
}

# Invoke a shell-script on the test scene file $1, placing the output
# into $2.  Return status is 0 for a successful run, and non-zero if
# snogray failed.
#
# The first argument to the shell script is the shell-script filename,
# and the second is the name to which to write the output image.
#
# The following environment variables are defined when running a
# script; all file/directory names are fully-specified and absolute:
#
#  SNOGRAY	snogray executable
#  SNOGCVT	snogcvt executable
#  SNOGDIFF	snogdiff executable
#  SNOGRAY_DIR  Directory where snogray executable is located
#
#  PBRT		PBRT executable
#
#  SNOGRAY_TEST_SCRIPT		Test shell-script being executed
#  SNOGRAY_TEST_SCRIPT_DIR	The test shell-script's directory
#  SNOGRAY_TEST_RUN_DIR		A temporary directory available for scratch use
#  SNOGRAY_TEST_OUT_DIR		The directory in which results should be placed
#
run_sh_script ()
{
  script="$1"; shift
  output="$1"; shift

  rm -f "$rundir"/*

  (
    cd "$rundir"
    SNOGRAY_DIR="$snogray_dir"
    SNOGRAY_TEST_SCRIPT="$script"
    SNOGRAY_TEST_SCRIPT_DIR="$(dirname "$script")"
    SNOGRAY_TEST_RUN_DIR="$rundir"
    SNOGRAY_TEST_OUT_DIR="$outdir"
    SNOGRAY_TEST_QUIET="$quiet"
    export SNOGRAY SNOGCVT SNOGDIFF PBRT SNOGRAY_DIR
    export SNOGRAY_TEST_SCRIPT SNOGRAY_TEST_SCRIPT_DIR
    export SNOGRAY_TEST_OUT_DIR SNOGRAY_TEST_RUN_DIR SNOGRAY_TEST_QUIET
    echo /bin/sh 2>&1 "$script" "$output"
  )
}

format_failure_log ()
{
  echo "$1 execution failed:"
  echo "   ----- START LOG -----"
  echo "$2" | sed 's@^@   @'
  echo "   ----- END LOG -----"
}

pfx_lines ()
{
  echo "$2" | sed "s@^@$1@g"
}

images_differ ()
{
  if /usr/local/src/pbrt-v2/src/bin/exrdiff -d 0.02 >/dev/null "$1" "$2"; then
    return 1
  else
    return 0
  fi
}

ref_image_differs ()
{
  false
}

update_ref_image ()
{
  echo "update_ref_image '$1' '$2'"
}

# Search for a parameter called "$1" and print its value if found,
# otherwise just print "$3".  The parameter is searched for in two
# locations: a parameter file "$2.params", and in the file "$2" itself;
# when searching in "$2", the parameter specification must be preceded
# by an appropiate comment delimiter, and the string "[test param]".
#
# If "$4" is "first", only the first matching parameter will be printed;
# if it is "multiple", all matchign parameters will be printed.
#
# Parameters are lines of the form "NAME = VALUE" or "NAME: VALUE",
# with VALUE being the rest of the line, and any amount of whitespace
# being ignore.
#
_get_param ()
{
  param_extra_file="$2.params"
  test -r "$param_extra_file" || param_extra_file=''

  $AWK '
  BEGIN {
    param_name="'"$1"'"
    param_file="'"$2"'"
    param_default="'"$3"'"
    multiple=("'"$4"'" == "multiple" ? 1 : 0)

    ws = "[ 	]*"
    param_line_magic_token_regexp = "\\[" ws "test param" ws "\\]"

    matched = 0
  }

  function config_for_file(filename  ,token)
  {
    valid_line_regexp = "^"
    param_match_regexp = ""

    if (filename !~ /[.]params$/) {
      if (filename ~ /[.](sh|pbrt)$/)
	comment_prefix = "#"
      else if (filename ~ /[.]lua$/)
	comment_prefix = "--"
      else
	comment_prefix = ""

      valid_line_regexp = valid_line_regexp ws comment_prefix
      param_match_regexp = ws param_line_magic_token_regexp
    }

    param_match_regexp = valid_line_regexp param_match_regexp ws param_name ws "[=:]" ws
  }

  {
    if (FILENAME != prev_filename) {
      config_for_file(FILENAME)
      prev_filename = FILENAME
    }
  }

  $0 ~ /^[ 	]*$/ { next; }
  $0 !~ valid_line_regexp { exit (1) }

  $0 ~ param_match_regexp {
    matched = 1
    sub (param_match_regexp, "")
    print $0

    if (! multiple)
      exit (0)
  }

  END {
    if (! matched)
      print param_default
    exit (matched ? 0 : 1)
  }' ${param_extra_file:+"$param_extra_file"} "$2"
}

get_param () { _get_param "$1" "$2" "$3" first; }
get_params () { _get_param "$1" "$2" "$3" multiple; }

# Print all arguments, each followed with a newline if it is non-empty.
#
cat_lines () {
  for arg in "$@"; do
    test x"$arg" = x || echo "$arg"
  done
}

run_one_test ()
{
  test="$(abs_filename "$1")"
  #test_name="$(basename "$test" | sed 's@^\(.*\)[.][^./]*$@\1@')"
  test_name="$(basename "$test")"
  test_dir="$(dirname "$test")"

  case "$test" in
    *.lua|*.pbrt|*.sh)
      failures=''
      pbrtout=''

      testout="$outdir/$test_name.snogray-out.$out_ext"

      if test $(get_param ignore "$test" no) = yes; then
	return 0
      fi

      if test x"$refdir" != x; then
	ref_image="$refdir/$test.$reference_ext"
      else
	ref_image=''
      fi

      printf "  $test_name..."

      case "$test" in
	*.lua|*.pbrt)
	  testlog=$(run_snogray "$test" "$testout") ;;
	*.sh)
	  testlog=$(run_sh_script "$test" "$testout") ;;
      esac

      if test $? -eq 0; then
	# snogray succeeded
	
	# See if there's a reference image, and compare against it
	#
	if test x"$ref_image" != x && test -r "$ref_image"; then
	  if ref_image_differs "$testout" "$ref_image"; then
	    failures=$(cat_lines "$failures" "Reference image differs: $ref_image")
	  fi
	fi

	# Test PBRT scene to compare against, which will be run using
	# PBRT.  This will have no effect unless it is a file ending
	# with ".pbrt".  By default this is the same as the input
	# file.
	#
	pbrt_test="$test_dir/$(get_param pbrt_reference "$test" "$test_name")"

	# Maybe run PBRT and compare its result too
	#
	case "$pbrt_test" in
	  *.pbrt)
	    pbrtout="$outdir/${test_name}.pbrt-out.$out_ext"

	    pbrtlog=$(run_pbrt "$pbrt_test" "$pbrtout")

	    if test $? = 0; then
	      # PBRT succeeded
	      if images_differ "$testout" "$pbrtout"; then
		failures=$(cat_lines "$failures" "PBRT output differs")
		if test x"$log_dir" != x && test -r "$pbrtout"; then
		  cp "$pbrtout" "$log_dir"
		fi
	      fi
	    else
	      # PBRT failed
	      failures=$(cat_lines "$failures" $(format_failure_log PBRT "$pbrtlog"))
	    fi
	    ;;
	esac

	# See if there are "compare_with" params, and if so, also run
	# snogray on those, and compare the results
	#
	for compare in $(get_params compare_with "$test"); do
	  compare_file="$test_dir/$compare"
	  compare_out="$outdir/${test_name}.compare-out.$compare.$out_ext"

	  # Find or generate an image file to compare
	  #
	  compare_prev_output_file="$outdir/${compare}.snogray-out.$out_ext"
	  if test -r "$compare_prev_output_file"; then
	    # re-use previously generate output file for $compare
	    cp "$compare_prev_output_file" "$compare_out"
	  else
	    # generate it
	    compare_log="$(run_snogray "$compare_file" "$compare_out")"
	  fi

	  if test $? = 0; then
	    if images_differ "$testout" "$compare_out"; then
	      failures=$(cat_lines "$failures" "Comparison output '$compare' differs")
	      if test x"$log_dir" != x && test -r "$compare_out"; then
		cp "$compare_out" "$log_dir"
	      fi
	    fi
	  fi
	done

      else
	# snogray failed
	failures=$(cat_lines "$failures" "$(format_failure_log snogray "$testlog")")
      fi

      if test x"$failures" = x; then
	echo "OK"

	if test x"$ref_image" != x; then
	  case $update_ref_images in
	    always)
	      update_ref_image "$testout" "$ref_image" ;;
	    new_only)
	      test -r "$ref_image" || update_ref_image "$testout" "$ref_image";;
	  esac
	fi
      else
	echo "FAILED:"
	echo "$(pfx_lines "     " "$failures")"

	if test x"$log_dir" != x; then
	  echo "$failures" > "$outdir/$test_name.log"
	  test -r "$testout" && cp "$testout" "$log_dir"
	fi
      fi
      ;;
  esac
}

run_tests ()
{
  for test in "$@"; do
    if test -d "$test"; then
      run_tests "$test"/*

      if test -r "$test/SUBDIRS"; then
	run_tests $(cat "$test/SUBDIRS")
      fi
    else
      run_one_test "$test"
    fi
  done
}

run_tests "$@"
